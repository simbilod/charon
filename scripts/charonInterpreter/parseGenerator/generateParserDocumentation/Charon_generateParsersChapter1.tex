

\section{Charon's GenerateInterpreter script}

The Charon interpreter is a Python script that is intended to simplify
the use of Charon by providing a simpler, easier to read syntax than
creating xml or yaml parameter lists.  One of the most complex tasks
the script must undertake is to parse the user's input and map it to
the parameter lists.  Or rather, one of the most complex tasks for the
developer to undertake is to write the parsers that provide the
mapping.  This can be particularly challenging for developers who are
developing routinely in C++, but rarely or never in Python.  

The Charon generateInterpreter script is a script that writes scripts.
Namely, it will take a simplified input provided by a developer who is
required to generate new input to Charon based on a new feature or
otherwise modified capability of the software and write parsers that
will interpret and map user input to parameter list specifications.
The Charon interpreter file can contain single lines of input or
multiple lines of input collected into nested blocks.  The block input
is general and so nesting can go arbitrarily deep.  In principle,
however, the depth of nesting should be kept shallow and replaced with
creativity in the input syntax.  This avoids confusion for users.

The following sections describe the input file syntax for the parser
generators for both line inputs and block inputs.

\subsection{Charon Create Line Parser}

The most fundamental element of the Charon interpreter is the line of
input regardless of whether that line exists in isolation or is a part
of a larger block of input.  In either case, the line of interpreter
input must be defined by its own parser.  The parser takes the line of
input and will map it to, usually, many lines of XML or YAML input in
the parameter lists used by Charon.  The createLineParser script in
Charon's generateInterpreter scripts takes input that ultimately
defines the interpreter line, all of its arguments and options
including user help content and maps it to parameter list content that
Charon and it's libraries use.  This section describes the input syntax
that creates the parser for a single line of input regardless of
whether it's part of a block or not.

The generateInterpreter script that creates the parser will read input
files from an immediate subdirectory called parseInputs.  That
directory will, in general, contain inputs for all of the
interpreter's parsers.  If the script is called without arguments, it
will sequentially process every input file in the subdirectory.
Alternatively, the name of the input file can be specified as a
command line argument to the script and only that input file will be
processed.  All of the line parser input files {\bf{must}} contain a
.inp suffix.

The create line parser input file contains several lines that
ultimately define the parser.  In general, the input file is case
insensitive except in certain instances where the parameter list
information is defined.  Parameter lists are case sensitive.
Moreover, the input file lines can be included in any order in the
file, but they will be presented here in what the author considers to
be a logical order.

The input to the parser generator can be grouped into two larger
categories: the lines that define the interpreter input, and the lines
that define the parameter list content generated by the parser.  The
parser that gets created is actually a Python class which the
interpreter will instantiate into an object that provides mapping
between user input to the interpreter and the parameter list output.
The interpreter group is presented first.

The first order of business is to name the new Python class that
defines the parser.  It is accomplished by the line:
\begin{lstlisting}
interpreter name NewParser
\end{lstlisting}
This line tells the generator to create a new Python class
called \begin{lstlisting}charonLineParserNewParser\end{lstlisting} in a
  file
  named \begin{lstlisting}charonLineParserNewParser.py\end{lstlisting} in
  the adjacent parsers subdirectory.  In this instance,
  ``interpreter'' and ``name'' are case insensitive whereas
  ``NewParser'' is not.  Case if the class and file names follow the
  input.

The line with the specifiers ``interpreter inputLine'' creates the
input syntax that the interpreter will use.
\begin{lstlisting}
interpreter inputLine (parse keyword) {requiredArgument} [(first option) {firstOptionArgument} [(second option) {secondOptionArgument}]]
\end{lstlisting}
There is no case sensitivity in this line.  The initial part of this
line after the specifiers tells the generator what the required parts
of the line are and what the keywords are that trigger the parser.
This part is
\begin{lstlisting}
(parse keyword) {requiredArgument}
\end{lstlisting}
The phrase that's contained in parentheses is the keyword that
triggers the parser.  The string in curly braces defines the argument
to the required part of the line.  There can be any number of
arguments to any part of the line, but they must each be defined by a
single, unspaced string.  A simple example is the input of the state,
or initial guess, file that will be used in a Charon job.  The
generator input line could be
\begin{lstlisting}
interpreter inputLine (Import State File) {filename}
\end{lstlisting}
This tells the parser to look for a the keywords ``import state file''
and use ``filename'' as an argument to define parameter list
entries.  For example,
\begin{lstlisting}
Import state file myInitialGuess.exo
\end{lstlisting}
in a Charon input file will create parameter list elements that tell
Charon to look for the file ``myInitialGuess.exo'' as an initial
guess.  Import state file is not case sensitive, but the argument
``myInitialGuess.exo'' must be.

The parser can also be instructed to look for options on the line.
This is done by enclosing optional pieces and arguments in square
braces and nested as shown in the generic example.  A more concise
example for state files is
\begin{lstlisting}
interpreter inputLine (Import State File) {filename} [(at Index) {index}]
\end{lstlisting}
This tells the parser that there may be (not required) additional
instruction to use a particular time or parameter plane in the
imported state file and is indicated by the optional parse keywords
``at index.''  By continuing with the earlier example, a line of input
to the interpreter could be
\begin{lstlisting}
Import state file myInitialGuess.exo at index 3
\end{lstlisting}
will tell Charon to read in a file called myInitialGuess.exo and to
use the third time plane in that file as the initial guess to the
simulation.  In this case, ``at index 3'' can be omitted and certain
default behaviors will be employed.  Those are defined in the second
group of the input file that defines the parameter list entries.

The second group of inputs all begin with an ``xml'' prefix regardless
of whether the interpreter is ultimately instructed to generate XML
formatted parameter lists or ``yaml'' formatted parameter lists.  The
one that must {\bf always} be included are the lines that are
indicated by ``xmlRequired.''  An example of a required line is
\begin{lstlisting}
xmlRequired Charon->Mesh->Exodus File,File Name,string,{filename}
\end{lstlisting}
The xmlRequired lines will map directly from the non square bracketed
parts of the interpreter input line to xml formatted parameter list.
In general, a single line interpreter input may map to multiple lines
of parameter lists.  Each line of the parameter list that maps to
required input must be separately defined and so there is no limit to
the number of xmlRequired lines that can be specified.  The only
necessary thing is that arguments to the required interpreter input
line must appear in at least one of the xmlRequired lines.  In this
case, it is the ``filename'' argument.  In the xmlRequired line---and
all other xml lines described later---the initial part of the line is
case insensitive.  Everything following that defines the parameter and
how it is nested in the parameter list is case sensitive because
parameter lists are case sensitive.

The format of the parameter list line follows from the requirements of
Teuchos \cite{teuchosCitation} parameter lists and parameters.  Each
parameter must have a name, type and value.  These are defined in the
interpreter by the comma separated section of the example above.  In
this case, ``File Name'' is the parameter name, ``string'' is the
parameter type and ``{filename}'' is the parameter value which will be
filled in by the argument value supplied by the user in the
interpreter input.  In other words, the xmlRequired line above will
produce the following XML formatted parameter list output,
\begin{lstlisting}
<ParameterList name="Charon">
  <ParameterList name="Mesh">
    <ParameterList name="Exodus File">
      <Parameter name="File Name" type="string" value="{filename}" />
    </ParameterList>
  </ParameterList>
</ParameterList>
\end{lstlisting}

The nesting of the xml output is defined by the parts of the required
line that are separated by the arrow, ``->'' characters as seen in the
filename example.

Optional inputs are very similar but but the possibility of multiple
options requires additional information---namely a parse keyword
associated with the option.  An example of an optional line that is
consistent with earlier examples is,
\begin{lstlisting}
xmlOptional (at Index) Charon->Mesh->Exodus File,Restart Index,int,{index}
\end{lstlisting}
The syntax in this case is identical to the required syntax except
that the parse keyword ``at index'' has been included.  Other options
will have separate keywords.  As in the required line, there may be
any number of xmlOptional lines connected to a single option in the
interpreter input.  This xmlOptional line will create the XML
formatted lines,
\begin{lstlisting}
<ParameterList name="Charon">
  <ParameterList name="Mesh">
    <ParameterList name="Exodus File">
      <Parameter name="Restart Index" type="int" value="{index}" />
    </ParameterList>
  </ParameterList>
</ParameterList>
\end{lstlisting}
Note that this optional input will {\bf only} be included in the
parameter list if the user supplies the option.  Otherwise it will not
appear.

The final category in the xml input group are xmlDefault parameters.
These parameters are always included in the ultimate parameter list
and never contain any arguments.  For example, Charon parameter list
elements that contain the state guess file must also define the initial
file format.  For Charon, this never changes from the exodus file
format and as such requiring it in input is a waste of the user's time
and serves only to make for long, confusing input prone to error.
xmlDefault parameters are the cure for this.  Consistent with the
earlier examples,
\begin{lstlisting}
xmldefault  Charon->Mesh,Source,String,Exodus File
\end{lstlisting}
and tells Charon that the state file type will always be an exodus
file.  This line produces the XML formatted parameter list,
\begin{lstlisting}
<ParameterList name="Charon">
  <ParameterList name="Mesh">
    <Parameter name="Source" type="string" value="Exodus File" />
    </ParameterList>
  </ParameterList>
</ParameterList>
\end{lstlisting}

To put this all together, the createLineParser input file,
\begin{lstlisting}
interpreter name ImportStateFile

interpreter inputLine (Import State File) {filename} [(at Index) {index}]

xmlRequired Charon->Mesh->Exodus File,File Name,string,{filename}

xmlOptional (at Index) Charon->Mesh->Exodus File,Restart Index,Int,{index}

xmlOptional (second Option) Charon->Mesh->Exodus File,Option Two,String,{option2}

xmldefault  Charon->Mesh,Source,String,Exodus File
xmldefault  Charon->Mesh->Exodus File,Restart Index,Int,-1
\end{lstlisting}
will create a parser that will take the interpreter input line
\begin{lstlisting}
import state file powerMOSFET.sg.Vdrain.exo at index 7
\end{lstlisting}
that will produce the XML formatted parameter list
\begin{lstlisting}
<ParameterList name="Charon">
  <ParameterList name="Mesh">
    <Parameter name="Source" type="string" value="Exodus File" />
    <ParameterList name="Exodus File">
      <Parameter name="File Name" type="string" value="powerMOSFET.sg.Vdrain.exo" />
      <Parameter name="Restart Index" type="int" value="7" />
    </ParameterList>
  </ParameterList>
</ParameterList>
\end{lstlisting}

One final comment must be made about default lines {\em vis-a-vis}
optional lines.  In this example, the ``Restart Index'' parameter has
been included in both default and optional input.  Parameter list
entries are prioritized such that default entries will always be
included, but will always be replaced by optional entries when they
are specified.  In Charon, the restart index need not always be
supplied.  When it isn't, a restart index of 0 is implied.  That is,
the xmlDefault ``Restart Index'' could have been left out without
penalty.  It is ultimately up to the developer how explicit they feel
the parameter list should be.  The author prefers more explicit to less
as the user won't normally be burdened by the longer parameter list
input, but its presence could be found useful at times.

Lastly, the interpreter is set up to provide help to the user when
requested.  For this reason, help lines are included as well that are
not related to parameter lists, but only to interpreter input.  The
developer must always include the two entries,
\begin{lstlisting}
interpreter shortHelp {Specify state file name and state index}
\end{lstlisting}
and
\begin{lstlisting}
interpreter longHelp {Specify the name of the file (exodus) that contains the states for input/initial guess. <> Optionally, specify the index of the time plane or parameter plane if the file contains multiple states. <> filename is the name of the file.  It is case sensitive. <> index is the integer index of the state to be used as input.}
\end{lstlisting}
edited appropriately for the input line.  With the interpreter help
option, the line itself will be echoed absent the () characters along
with the requested verbosity. The short help line should always be
succinct and in active voice.  The long help line is less rigidly
defined, but in general ought to be a more comprehensive description
of the input and should always contain a description of the arguments
in the line.  The ``<>'' characters inserted into the long help string
connote a line break for more attractive, formatted output of the help
line.

\subsubsection{Optional Priority Specification}

All of the xml lines in the parser input file will have a default
priority associated with it.  xmlRequired and xmlOptional each default
to a priority of 2.  xmlDefault lines default to a priority of 1.  The
higher the number, the higher the priority.  This is illustrated in
the import state file parser with the restart index.  The default
value for the index is -1.  If the user specifies the index in the
input file to be 2, for example, the xmlOptional line that handles
that option takes priority over the xmlDefault line that sets the
index to -1 and so ultimately, the index is set equal to 2.

There are occasions when more than one parser generates the same line
of xml parameter input that may conflict.  An example of this is the
ohmic BC line,
\begin{lstlisting}
BC is ohmic for drain on bulk swept from 0 to 2
\end{lstlisting}
This line creates a sweep of the voltage on the drain contact to vary
from 0 to 2.  The default initial step size in the sweep will be 1
volt.  This might be too large a step size to start with.  For this
reason, there is a sweep options block wherein the user can modify the
behavior of the sweep.  For example,
\begin{lstlisting}
start sweep options
      initial step size = 0.5
end sweep options
\end{lstlisting}
This modifies the size of the initial step in the sweep.  A problem
arises when the sweep options block appears in the input file before
the BC line.  The initial step size in the sweep options block will
get overridden by the step size in the BC parser.  The reason for this
is that the default initial step size specified in the BC parser is
actually a part of the xmlOptional behavior for a sweep of a BC.  So
the two parameter inputs will have the same priority.  The best way to
handle these situations is to use an optional custom priority for the
initial step size parameter in the sweep options block.  It is
specified thus,
\begin{lstlisting}
xmlRequired Charon->Solution Control->LOCA->Step Size,Initial Step Size,double,{stepSize} priority 5
\end{lstlisting}
If the priority keyword does not exist in the previous line, the
default priority of 2 will be assigned that parameter.  By adding the
\texttt{priority 5} addendum to the line, one guarantees that a higher
priority is assigned to this specification and will override the BC
step size specification regardless of the order of appearance in the
input file.

\subsection{Charon Create Block Parser}

In many instances, it is most convenient to organize input into
blocks.  The Charon interpreter allows for this, but it is encouraged
that nesting of these blocks be kept to a minimum depth.  The
generateInterpreter script is instructed to create parsers of block
input in a very similar way that line parsers are created.  The
difference is organizational.  Block input files are read from the
same parseInputs subdirectory as line parser inputs, but all contain
the .blockinp suffix.  An example of a material model block parser
generator input is,
\begin{lstlisting}
interpreterBlock name MaterialBlock

interpreterBlock (start Material Block)
\end{lstlisting}
This tells generateInterpreter to create a blockParser class called
charonBlockParserMaterialBlock in a file called
charonBlockParserMaterialBlock.py in the parsers directory.  The
keywords in the interpreter file that open the block are ``start
Material Block'' (not case sensitive).  It is implied that ``end
Material Block'' will close the block in the interpreter file and must
be provided by the user.  Each block must have parameter lines inside.
A separate input file that defines the parser for each of those lines
as described in the previous subsection must be included.  The line
parser input are organized into subdirectories that mimic the nesting
of the interpreter block parser.  If the MaterialBlock parser in the
example is defined in the .blockinp file, it is implied that there is
also a subdirectory called parseInputs/MaterialBlock.  This
subdirectory includes all of the line parsers that are defined in the
block.  For example, if the material is to be named, the
parseinputs/MaterialBlock directory will contain a line parser input
file called createMaterialName.inp.  The creation of the MaterialBlock
block parser in the parsers directory will also create a
parsers/MaterialBlock subdirectory that contains all line parsers
associated with that first, nested level of the block.  In other
words, the input file parseInputs/MaterialBlock/createMaterialName.inp
will create parsers/MaterialBlock/charonLineParserMaterialName.py.

It is possible for blocks of interpreter input to contain other blocks
of input.  That is, the parseInputs/MaterialBlock directory might
contain a createDoping.blockinp file that provides for a block of line
parsers in that block.  Naturally then, there will be a directory
called parseInputs/MaterialBlock/Doping that has in it line parser
inputs that defined the parsers for each line in the doping block.  To
lay it out, there is a block parser input file called
createMaterialBlock.blockinp,
\begin{lstlisting}
interpreterBlock name MaterialBlock

interpreterBlock (start Material Block)
\end{lstlisting}
which creates a block parser invoked by the ``start Material Block''
keywords.  There are also files in the parseInputs/MaterialBlock
directory called createMaterialName.inp,
\begin{lstlisting}
interpreter name MaterialName

interpreter inputLine (material name) = {materialName}

interpreter shortHelp { }

interpreter longHelp { }
\end{lstlisting}
as well as another block parser input called createDoping.blockinp,
\begin{lstlisting}
interpreterBlock name Doping

interpreterBlock (start Doping) 
\end{lstlisting}
This implies another subdirectory parseInputs/MaterialBlock/Doping
that contains line parsers for the doping.

An interpreter input line might read something like,
\begin{lstlisting}
start Material Block
    material name = Si
    start Doping
      ....
    end Doping
end Material Block
\end{lstlisting}
All parameter list input will be generated according to the individual
line parsers as described in the previous section.  The generated
parsers are organized into the parsers directory with the same
subdirectory structure as the parseInputs directory structure.



\subsection{Charon Create Modifiers}



The parsers created by the generate interpreter script and all
associated inputs are relatively simple mappings.  They translate
simple, easy to understand user input to the multiple lines of nested
xml formatted input that is native to Charon/Teuchos parameter lists.
They contain very little logic.

It is sometimes necessary to include logic in a parser.  This is
possible in the Charon interpreter by using special modifier scripts,
though the inputs should be designed where there is as little reliance
on modifiers as possible.  One example is doing parameter sweeps.  The
input line for a contact boundary condition may read as follows:
\begin{lstlisting}
BC is contact on insulator for gate on gateoxide with work function 4.0 swept from 0 to 2
\end{lstlisting}
Clearly, the user is requesting a sweep from 0 to 2 volts on the gate
contact of a FET.  In the xml input for Loca, the range is specified
as a minimum and maximum value and there is a signed initial step size
that determines the direction of the sweep---from 0 to 2 in a positive
direction in this case.

If the requested boundary condition and associated voltage sweep is
slightly different, say,
\begin{lstlisting}
BC is contact on insulator for gate on gateoxide with work function 4.0 swept from 0 to -2
\end{lstlisting}
the simple mapping breaks down.  The minimum Loca parameter value will
be set to 0 and the maximum to -2 with a sweep in the wrong direction.
These special cases where a simple mapping is not possible, the
interpreter allows for developer-defined modifiers to produce the
correct behavior.  This is the one instance where the developer must
write Python code when developing parsers for the interpreter.

All of the Python code the developer must write is contained in a
function titled {\em testForModification}.  In principle, a parser may
have an unlimited number of modifiers, but they should be kept to a
minimum to avoid convoluting the interpreter.  Any modifier will
always be associated with a single, specific parser and a single file
contains all modifiers that will be associated with that parser.  The
file must have the same canonical name as its associated parser. E.g.,
the parser input file for the boundary condition described here is
{\texttt{createContactOnInsulator.inp}}.  The associated files that
define the modifiers must then be named
\texttt{createContactOnInsulator.modifierinp.py}. All modifiers
associated with this parser will be defined in the file of this name.
Each modifier will be a function called \texttt{testForModification}.
Each identically named function is contained inside a block that
starts \texttt{start modifier X} and ends \texttt{end modifier X}
where \texttt{X} is a unique integer number for the modifier.  For
example, the Python code that handles the voltage sweep input
described herein is:
\begin{lstlisting}
start Modifier 0

def testForModification(self,pLList):

    foundMinValue = False
    foundMaxValue = False
    foundStepSize = False
    makeMinMaxModification = False
    makeStepSizeModification = False
        
    for lineNumber, line in enumerate(pLList):

        # Capture the min value
        if line.find("Charon->Solution Control->LOCA->Stepper,Min Value,double") >= 0:
            lineParts = line.split(",")
            minValue = lineParts[-1]
            minValueLine = lineNumber
            foundMinValue = True

        # Capture the max value
        if line.find("Charon->Solution Control->LOCA->Stepper,Max Value,double") >= 0:
            lineParts = line.split(",")
            maxValue = lineParts[-1]
            maxValueLine = lineNumber
            foundMaxValue = True

        # Capture the initial step size
        if line.find("Charon->Solution Control->LOCA->Step Size,Initial Step Size,double") >= 0:
            lineParts = line.split(",")
            initialStepSize = lineParts[-1]
            initialStepSizeLine = lineNumber
            foundStepSize = True

    if foundMinValue == True and foundMaxValue == True:
        if float(minValue) > float(maxValue):
            makeMinMaxModification = True
            replacementMinLine = "Charon->Solution Control->LOCA->Stepper,Min Value,double,"+maxValue
            replacementMaxLine = "Charon->Solution Control->LOCA->Stepper,Max Value,double,"+minValue

    if makeMinMaxModification and float(initialStepSize) > 0:
        makeStepSizeModification = True
        newStepSize = str(-float(initialStepSize))
        replacementStepSizeLine = "Charon->Solution Control->LOCA->Step Size,Initial Step Size,double,"+newStepSize


    # Make modifications
    if makeMinMaxModification == True:
        pLList[minValueLine] = replacementMinLine
        pLList[maxValueLine] = replacementMaxLine

    if makeStepSizeModification == True:
        pLList[initialStepSizeLine] = replacementStepSizeLine

    return pLList

end Modifier 0
\end{lstlisting}
Should this parser require a second modifier, it would be contained in
\texttt{start modifier 1} and \texttt{end modifier 1} and the function
name would still be named \texttt{testForModification}.  The
generateInterpreter script will create the necessary boiler plate
required to generate modifier script for the interpreter.

The modifiers will only be executed when their use is called out in
the parser itself.  To do this, a special line must be specified in
the parser input files.  The parser input file for the contact BC is
\begin{lstlisting}

interpreter name ContactOnInsulator

interpreter inputLine (BC is contact on insulator for) {sidesetID} on {geometryBlock} with work function {workFunction} [(fixed at) {potential}[ (swept from) {potential1} to {potential2}]]

interpreter shortHelp {Specify the potential on a contact}

interpreter longHelp {Specify the potential on a contact. <> sidesetID is the contact name/type <> geometryBlock is the geometry name the contact is attached to <> potential is the value in volts}

xmlRequired Charon->Boundary Conditions->{sidesetID}ANONYMOUS,Type,string,Dirichlet
xmlRequired Charon->Boundary Conditions->{sidesetID}ANONYMOUS,Sideset ID,string,{sidesetID}
xmlRequired Charon->Boundary Conditions->{sidesetID}ANONYMOUS,Element Block ID,string,{geometryBlock}
xmlRequired Charon->Boundary Conditions->{sidesetID}ANONYMOUS,Equation Set Name,string,ELECTRIC_POTENTIAL
xmlRequired Charon->Boundary Conditions->{sidesetID}ANONYMOUS,Strategy,string,Contact On Insulator
xmlRequired Charon->Boundary Conditions->{sidesetID}ANONYMOUS->Data,Work Function,double,{workFunction}

xmlOptional (fixed at) Charon->Boundary Conditions->{sidesetID}ANONYMOUS->Data,Voltage,double,{potential}

# Set the data parameter to a string
xmlOptional (swept from) Charon->Boundary Conditions->{sidesetID}ANONYMOUS->Data,Varying Voltage,string,Parameter

# Modify the solver type from NOX to LOCA
xmlOptional (swept from) Charon->Solution Control,Piro Solver,string,LOCA

#LOCA Parameters
xmlOptional (swept from) Charon->Solution Control->LOCA->Predictor,Method,string,Constant
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Continuation Method,string,Natural
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Initial Value,double,{potential1}
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Continuation Parameter,string,Varying Voltage
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Max Steps,int,1000
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Max Value,double,{potential2}
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Min Value,double,{potential1}
xmlOptional (swept from) Charon->Solution Control->LOCA->Stepper,Compute Eigenvalues,bool,0
xmlOptional (swept from) Charon->Solution Control->LOCA->Step Size,Initial Step Size,double,1.0
xmlOptional (swept from) Charon->Solution Control->LOCA->Step Size,Aggressiveness,double,1.0

# Set the parameters block
xmlOptional (swept from) Charon->Active Parameters,Number of Parameter Vectors,int,1
xmlOptional (swept from) Charon->Active Parameters->Parameter Vector 0,Number,int,1
xmlOptional (swept from) Charon->Active Parameters->Parameter Vector 0,Parameter 0,string,Varying Voltage
xmlOptional (swept from) Charon->Active Parameters->Parameter Vector 0,Initial Value 0,double,{potential1}
xmlOptional (swept from) use Modifier 0
\end{lstlisting}

This input creates a parser that specifies the voltage on the contact
that is either fixed or swept from one voltage to another.  The use
case described here is for a voltage sweep that may be swept from high
to low or low to high.  The optional argument \texttt{swept from}
requires the modifier to guarantee proper execution and so the line
\texttt{use Modifier 0} is added to that option.  This will trigger
the interpreter to execute that modifier when the sweep option is
selected by the user.

No modifier is executed until the input file has been completely
parsed.  The parameter list that is sent to the modifier script for
modification will be the completed one for the current job.

